;
; For the MOP ops change SETUPB to SETUPW
; Self test: after power reset MDCINI works incorrectly
;
;
	.TITLE	DELQA - DELQA logic
	.IDENT	/x01.00/

ECTMOP	= 1

	.SBTTL	Definitions
	.SBTTL	- Memory map and registers
;===========================================================================
; Memory addresses
;---------------------------------------------------------------------------
; External bus access
; 174456 - CSR
; 174454 - VAR
; 174450 - RBDL
; 174444 - TBDL
; 174440 - Base address
;
; Internal bus access
; 160000 - 167777 ROM
; 024000 - 024012 BDL block
; 024020 - 024036 DMA registers
; 024040 - 024076 Ethernet registers
; 020000 - 023777 Transmit buffer
; 010000 - 017777 Receive buffer
; 000000 - 007777 RAM with control program
;
;---------------------------------------------------------------------------
; Register definitions
;---------------------------------------------------------------------------
; External registers
;
LQABAS	= 24100	    ; Base address
LQARLL	= LQABAS+4  ; Rx BD low ordera ddress bis
LQARLH	= LQABAS+6  ; Rx BDL high order address bits
LQATLL	= LQABAS+10 ; Tx BDL low order address bits
LQATLH	= LQABAS+12 ; Tx BDL high order address bits
LQAVAR	= LQABAS+14 ; Vector Address Register
LQACSR	= LQABAS+16 ; Control and Status Register
;
; Internal register
;
RAMTOP	= 010000    ; Upper program limit
;
;---Buffers----
RXBUF	= 10000	    ; Receive buffer address
RXBSIZ	= 4000	    ; Size of buffer (words)
TXBUF	= 20000	    ; Transmit buffer address
TXBSIZ	= 2000	    ; Size of buffer (words)
;
;----BD ROM----
BDROM	= 160000    ; BD ROM address
BDRSIZ	= 10000	    ; BD ROM size
;
;-----BDL------
BDLADR	= 24000	    ; BDL buffer address
BDLSTW	= BDLADR+8. ;
;
;-----DMA------
DMAOP 	= 24020	    ; DMA operation/status
DMACNT	= 24022	    ; DMA words counter (2's compl.)
DMALAD	= 24024	    ; Local buffer address (offset)
DMAHLA	= 24026	    ; Low bits host memory address
DMAHHA	= 24030     ; High bits host memory address
DMATIM 	= 24032	    ; DMA operation timeout timer
;
;---Ethernet---
ECTST	= 24040	    ; Ethernet control/status bits
; *** read operation ***
; lbyte - {2'b0, bdl_h, setup, extmode, intemode, intmode, rxmode}
; hbyte - {1'b0, rxrdy, txdone, crs_err, mdc_err, e_txer, rx_err, rx_crc_err};
; *** write operation ***
; lbyte - {rxdone, txrdy, bdl_h, setup, 4'b0}
;--------------
ECNTB	= 24042     ; Bytes counter for transmit/receive operations
; write - transmit; read - receive
;--------------
EMDVAL	= 24044     ; Ethernet MD input/output value
;--------------
EMDCTR	= 24046     ; Ethernet MD control/status
; Write operation bits (control)
;  6    : opearation (1/0 - write/read)
;  5    : set to 1 to start opearation
;  4:0  : reg. address
; Read operation bits (status)
;  15   : 1/0 - ready/busy
;  14,13: speed (10-1000; 01-100; 00-10; 11-reserved)
;  12   : duplex (1-full; 0-half)
;  11   : reserved (0)
;  10   : 1-MDI crossover; 0-MDI
;  9    : receiver (1-ready; 0-not ready)
;  8    : link (1-yes; 0-no)
;  7    : reserved (0)
;  6    : opearation (1/0 - write/read)
;  5    : set to 1 to start opearation
;  4:0  : reg. address
;--------------
EGMOD	= 24050
; read  - {bdmode, 6'b0, rbt_ena, stm_ena, promis, mcast, rxa_eth, txa_eth, led, led, led}
; write - {6'b0, santm_reset, 2'b0, promis, mcast, rxa_eth, txa_eth, led, led, led}
;--------------
ESADR	= 24060     ; +3 - station address + checksum. RO
;
	.SBTTL	- Bit definitions
;===========================================================================
; General bit definitions
;---------------------------------------------------------------------------
BT.15	= 100000
BT.14	= 040000
BT.13	= 020000
BT.12	= 010000
BT.11	= 004000
BT.10	= 002000
BT.09	= 001000
BT.08	= 000400
BT.07	= 000200
BT.06	= 000100
BT.05	= 000040
BT.04	= 000020
BT.03	= 000010
BT.02	= 000004
BT.01	= 000002
BT.00	= 000001
;---------------------------------------------------------------------------
;  CSR bit definitions
CS.RI	= BT.15	; Receive interrupt request
CS.SE	= BT.10	; Sanity timer
CS.EL	= BT.09	; External loopback
CS.IL	= BT.08	; Internal loopback
CS.XI	= BT.07	; Transmit interrupt request
CS.IE	= BT.06	; Interrupt enable
CS.RL	= BT.05	; Receive List Invalid/Empty
CS.XL	= BT.04	; Transmit List Invalid/Empty
CS.BD	= BT.03	; Boot/Diagnostic ROM load
CS.NI	= BT.02	; Nonexistance-memory timeout Interrupt
CS.SR	= BT.01	; Software reset
CS.RE	= BT.00	; Receiver enable
;---------------------------------------------------------------------------
; VAR bit definitions
VR.MS	= BT.15	; Mode select
VR.OS	= BT.14	; Options switch
VR.RS	= BT.13	; Request to execute self-test
VR.S3	= BT.12	;
VR.S2	= BT.11	; Self-test status
VR.S1	= BT.10	;
VR.ID	= BT.00 ; Identity test bit
;---------------------------------------------------------------------------
; Address descriptor bits
BDES	= 2
AD.H	= BT.06	; High byte (beginning)
AD.L	= BT.07	; Low byte (termination)
AD.S	= BT.12	; Setup package indication
AD.E	= BT.13	; End of message
AD.C	= BT.14	; Chain address bit
AD.V	= BT.15	; Valid bit
INVLD	= 0
;---------------------------------------------------------------------------
; Twos complement of buffer size in words.
BSIZ	= 6
;
; Used and not last data segment
UNLST	= 140000
;---------------------------------------------------------------------------
; Bits defined for Transmit status word #1
TS.1GE	= BT.14	; indicates an error
TS.1CE	= BT.12	; indicates loss of carrier
TS.1ES	= BT.10	; indicates that the sanity timer was ...
		; ... enabled via switch S4 at powerup
TS.1AE	= BT.09	; indicates that the transmission was ...
		; ... aborted due to excessive collisions
;
; Bits defined for Receive status word #1
RS.1GE	= BT.14	; indicates an error
RS.1ES	= BT.13	; indicates a looped back Setup or ...
		; ... External Loopback frame
RS.1RE	= BT.11	; indicates that the internal loopback ...
		; ... operation was unsuccessful
RS.1BL	= BT.08!BT.09!BT.10 ; high order 3 bits of ...
			    ; ... receive byte length of frame
RS.1FE	= BT.02	; indicates a framing alignment error
RS.1CE	= BT.01	; indicates that a CRC error has been detected
;
; Bits defined for Receive status word #2
RS.2BL	= 377	; low order 8 bits of receive...
		; ...byte length of packet
;---------------------------------------------------------------------------
; Bits defined for DMAOP
DM.RDY	= BT.07	; Operation is completed
DM.NXM	= BT.06	; NMX error
DM.WRO	= BT.01	; DMA write operation
DM.RDO	= BT.00	; DMA read operation
RX.BFS	= BT.02	; Select receive buffer
TX.BFS	= BT.03	; Select transmit buffer
;---------------------------------------------------------------------------
; Bits defined for various errors
TX.ERR	= BT.00	; Transmit error
RX.ERR	= BT.01	; Receive error
NX.ERR	= BT.07	; NXM error
PH.ERR	= BT.06	; Phy error
;---------------------------------------------------------------------------
; Bits defined for Ethernet ECTST register
ET.RDD	= BT.07	; Receive operation has been completed
ET.TRD	= BT.06	; Ready to transmit
ET.SKB	= BT.05	; Skip byte
ET.STP	= BT.04	; Setup packet
ET.EXL	= BT.03	; External loop mode
ET.IEL	= BT.02	; Internal-external loop mode
ET.INL	= BT.01	; Internal loop mode
ET.REN	= BT.00	; Receiver is enabled
ET.RDY	= BT.14	; Packet has been received
ET.TXD	= BT.13	; Transmit operation has been completed
ER.CR	= BT.12	; Loss of carrier error
ER.MDR	= BT.11	; MDC error
ER.TXR	= BT.10	; Transmit error
ER.RDR	= BT.09	; Receive error
ER.CRR	= BT.08	; Receive CRC error
ER.RER	= ER.CR!ER.RDR!ER.CRR
;---------------------------------------------------------------------------
; Bits defined for EGMOD
BD.ROM	= BT.15	; Load BDROM
ST.RST	= BT.09	; Sanity timer reset
RB.ENA	= BT.08	; Remote boot enable
ST.ENA	= BT.07	; Sanity timer enable
ET.PRM	= BT.06	; Promiscuous mode
ET.MCT	= BT.05	; Multicast mode
EA.RXB	= BT.04	; Ethernet address bus to RXBUF
EA.TXB	= BT.03	; Ethernet address bus to TXBUF
EA.LED	= BT.00!BT.01!BT.02 ; LED bits
EA.LD1	= BT.00
EA.LD2	= BT.01
EA.LD3	= BT.02
;---------------------------------------------------------------------------
; Bits defined for MDC ops
MD.RDY	= BT.15	; Ready bit
MD.WR	= BT.06	; Write/read bit
MD.OP	= BT.05	; Start operation
MD.REG	= 37	; Register bits
MD.SRS	= 100000; Software reset
MD.LNK	= 400	; Link is ready
MD.RCV	= 1000	; Receiver is ready
;---------------------------------------------------------------------------
; Bits defined for the remote MOP codes
MOPRSM	= 5
MOPRBM	= 6
;
	.SBTTL	- Macro definition
;===========================================================================
; Macro definition
;
	.MACRO	IV, OFFSET, ADR
	.	= OFFSET
	.IF	NB, <ADR>
		.WORD	ADR
	.IFF
	.WORD	START
	.ENDC
	.WORD	340		; PS=340
	.ENDM
;
	.SBTTL	- Interrupt vectors table
;---------------------------------------------------------------------------
; Generate interrupt vectors table
;
	.ASECT
	. = 0
	IV	0
	IV	4
	IV	10
	IV	14
	IV	20
	IV	24
	IV	30
	IV	34
	IV	40
	IV	44
	IV	50
	IV	54
	IV	60
	IV	64
	IV	70
	IV	74
	IV	100, TMRIRQ	; 100 Timer 50Hz
;
	.SBTTL	Main routines
	.SBTTL	- Start point (initial settings)
;===========================================================================
; Start
;
START:
	MOV	#RAMTOP, SP	; SP is on the top
;
; Initial settings
;
	BIS	#1, @#LQABAS	; Block external access to the bus
	MTPS	#0		; Enable interrupt processing
; Init MAC address table
	MOV	#MACTAB, R4	; Initial address of the table
	MOV	#3, R5		; 3 words
	ADD	#6, R4		; 2-nd entry (FF)
2$:	MOV	#177777, (R4)+	; Fill 2-nd address
	SOB	R5, 2$
	MOV	#36., R5	; Number of the rest words
3$:	CLR	(R4)+		; Clear rest ...
	SOB	R5, 3$		; ... entries

.IF NE ECTMOP
; Init system message values and first MAC table entry
	MOV	#ESADR, R4	; Address of the SA ROM
	MOV	#MACTAB, R3	; Address of the MACTAB
	MOV	#SYSMCA, R2
	CLR	R5
	MOV	#3, R0		; Number of words
6$:	MOV	(R2)+,SYSMES(R5);
	MOV	(R4),SYSSRC(R5)	; Write to SYSSRC
	MOV	(R4), SYSDA(R5)	; Write to SYSDA
	MOV	(R4)+, (R3)+	; Write to MACTAB
	TST	(R5)+		; Shift dest. index
	SOB	R0, 6$
	MOV	#SYSPDC, R0	; Fill PAD
	ASR	R0
	MOV	#SYSPAD, R5
7$:	CLR	(R5)+
	SOB	R0, 7$
; Clear MOP counter
	MOV	#MCLZ, R5
	MOV	#MOPCNT, R4
8$:	CLR	(R5)+
	SOB	R4, 8$
.ENDC
; Init Ethernet transceiver
;	CALL	MDCINI		; Init ethernet transceiver
;	BCC	10$
;	HALT			; !!! Error !!!
; Final initialization
10$:	MOV	#BDLADR, R1	; Initial BDL local address to R1
	MOV	#DMAOP, R2	; DMAOP address to R2
	MOV	#LQACSR, R3	; LQACSR address to R3
	MOV	#177777, @R1	; Init first BDL word
	INCB	FSYSM		; Send system message
	CALL	SNTRES		; Reset sanity timer
	BIC	#1, @#LQABAS	; Unblock external access to the bus
;
	.SBTTL	- Main loop
;---------------------------------------------------------------------------
; Main loop
;
MLOOP:	BIT	#CS.XL, @R3	; Check XL-bit
	BNE	1$		; If not ready - continue
	CALL	TXP		; Else - call transmit operation
;1$:	BIT	#CS.RL, @R3	; Check RL-bit
;	BNE	2$		; If not ready - continue
1$:	BIT	#ET.RDY,@#ECTST	; Is there new data frame?
	BEQ	2$		; No - continue
	CALL	RXP		; Else - call receive operation
	BR	MLOOP
2$:	TST	@#EGMOD		; Ready to load BD ROM?
	BPL	3$		; No - continue
	CALL	PBDROM		; Yes - let's do it
3$:	BIT	#VR.RS,@#LQAVAR	; Check RS-bit
	BEQ	4$		; Not set - return
	CALL	TSTMOD		; Run tests if requested
4$:
.IF NE ECTMOP
	TSTB	FSYSM		; Time to send system mesage?
	BEQ	6$		; No - continue
	CALL	TXSYSM		; Yes - transmit it
.ENDC
;
6$:	BR	MLOOP		; Loop
;
	.SBTTL	- Transmit operation
;===========================================================================
;
TXP:	MOV	@#LQATLL, BDLL	; Get initial Tx BDL low order address bits
	MOV	@#LQATLH, BDLH	; Get initial Tx BDL high order address bits
;===============================================
; Get first/next BDL block data
TXL$:	MOV	BDLL, 6(R2)	; Set to DMA address (low order bits)
	MOV	BDLH, 10(R2)	; Set DMA address (high order bits)
	CALL	GETBDL		; Get BDL data
	BCC	1$
	JMP	28$		; If error - br to error proc.
;-----------------------------------------------
; Process V-bit
1$:	BIT	#AD.V, 2(R1)	; Check valid bit
	BNE	2$		; There is no V-bit - return
	BIS	#<CS.XL!CS.XI>, @R3 ; Set XL-bit in the CSR
;	BIS	#CS.XI, @R3	; Set XI-bit in the CSR
	JMP	32$
;-----------------------------------------------
; DMA transfer
2$:	MOV	#TXBUF, 4(R2)	; Initial local address to DMA reg
	BIS	#TX.BFS, @R2	; Select transmit buffer
	CALL	DMASWR		; DMA write operation
	BIC	#TX.BFS, @R2	; Deselect transmit buffer
	BCS	28$		; Got data with error, br to finish
;-----------------------------------------------
; Calculate number of bytes for transmition
	MOV	WCOUNT, R4	; Number of words to R4
	ASL	R4		; Convert to number of bytes
	BIT	#AD.L, 2(R1)	; Check for L-bit?
	BEQ	4$		; No L-bit - continue
	INC	R4		; Installed L-bit - decrease value
4$:	BIT	#AD.H, 2(R1)	; Check for H-bit?
	BEQ	6$		; No H-bit - continue
	INC	R4		; Installed H-bit - decrease value
	BIS	#ET.SKB,@#ECTST	; Set BDL-H bit in the emode register
6$:	MOV	R4, @#ECNTB	; Store byte count in the register.
	MOV	R4, BCOUNT	; Save copy
	CLR	STW1		; Init first transmit word
	CLR	STW2		; Init second transmit word
;
; Check and process S-bit
	BIT	#AD.S, 2(R1)	; Is the S-bit set?
	BEQ	9$		; No - br to continue
8$:	BIS	#ET.STP,@#ECTST	; Yes - set S-bit in the emode register
	NEG	R4		; 2-s complement of the byte count
	MOVB	R4, SETUPB	; Save copy to variable
	CALL	SPACK		; Process setup packet
	MOV	#20014, STW1	; Prepare setup packet ...
	MOV	#4140, STW2	; ... status words
;
; STE bit in the TSW1 (timer was enabled via switch S4 at powerup,
; this bit is only valid in DEQNA-lock mode).
9$:	MOV	@#LQAVAR, R0	; Get VAR value
	BIC	#^C<UNLST>, R0	; Clear all except 15:14 bits
	BNE	10$		; Condition not met, br to continue
	BIS	#TS.1ES, STW1	; Condition met, set STE bit
;
; E-bit
10$:	BIT	#AD.E, 2(R1)	; Execute the packet?
	BNE	20$		; Yes - transmit data
	BIS	#UNLST, STW1	; No - set bits in the 1-st status word ...
	CALL	STWPR		; ... and send status words to the host
	BCS	28$		; Carry is set - NXM error
	BR	26$		; Next BDL
;-----------------------------------------------
; Transmit frame data
20$:	CALL	SNTRES		; Reset sanity timer
	MOV	#ECTST, R0
	BIS	#ET.TRD,@R0	; Set "ready-to-transmit" bit
22$:	BIT	#<ET.TXD!ER.TXR>,@R0 ; Transmitted or error?
	BEQ	22$		; Not yet, loop
;-----------------------------------------------
; Error checking
	BIC	#ET.TRD, @R0	; Clear "ready-to-transmit" bit
	BIT	#ER.TXR, @R0	; Got an error?
	BEQ	24$
	BIS	#<TS.1GE!TS.1CE!TS.1AE>,STW1 ; Set error bits
	BISB	#TX.ERR, ERRFLG	; Set error flag
;-----------------------------------------------
; Send status words
24$:
.IF NE ECTMOP
	INC	MCTXP		; Inc. packets transmitted counter
	ADD	BCOUNT, MCTXB	; Inc. bytes transmitted counter
	ADC	MCTXB+2
.ENDC
	CALL	STWPR		; Send status words to host
	BCS	28$		; Carry is set - NXM error
;-----------------------------------------------
; Calculate next BDL address
26$:	ADD	#12., BDLL	; 6 words offset, ...
	ADC	BDLH		; ... add carry bit ...
	JMP	TXL$		; ... and loop
;-----------------------------------------------
; Carry is set, NXM error.
28$:	BISB	#<TX.ERR!NX.ERR>,ERRFLG	; Set error flags
	BIS	#<CS.NI!CS.XL!CS.RL!CS.XI>,@R3 ; Set NI-bit in the CSR
;
; Return
32$:
;	BIC	#1, @#EGMOD	; Clear indication
	RETURN
;
	.SBTTL	- Receive operation
;===========================================================================
;
RXP:
;
; We've got a frame, lets look what to do with it...
	MOV	@#ECTST, RECTST	; Get ethernet status
	BIC	#EA.RXB,@#EGMOD	; Set bus mode for RXBUF
.IF NE ECTMOP
	MOV	RXBUF+14, R0
	CMP	#220, R0	; ECTP (proto=0x9000)?
	BNE	1$		; No - continue
	CALL	ECTPR		; Call ECTP reply
	BR	2$		; Br to finish (Carry is set!)
;
1$:	CMP	#1140, R0	; DEC MOP (proto=0x6002)?
	BNE	4$
	CALL	MOPR
	BCS	4$
.IFF
	BR	4$
.ENDC
;
2$:	BIS	#EA.RXB,@#EGMOD	; Restore ethernet mode for RXBUF
	BIS	#ET.RDD,@#ECTST	; RL=1 - set "receive-done" bit ...
	RETURN			; ... and return
;
4$:	BIT	#CS.RL, @R3	; Check RL-bit
	BNE	2$		; RL=1 - abort processing
;
	BIT	#ET.STP, RECTST	; Setup?
	BNE	10$		; Yes - br to packer processing
	BIT	#ET.PRM,@#EGMOD	; Check MAC?
	BEQ	10$		; No - br to continue
	CALL	CMPMAC		; Yes - check it
	BCS	2$		; Not matched - return
;-----------------------------------------------
; Packet processing starts here
10$:	BIS	#EA.RXB,@#EGMOD	; Restore ethernet mode for RXBUF
	MOV	RECTST, R4	; Get ethernet status
	MOV	@#ECNTB, R0	; Get ethernet byte count
	MOV	@#LQARLL, BDLL	; Get initial Rx BDL low order address bits
	MOV	@#LQARLH, BDLH	; Get initial Rx BDL high order address bits
	MOV	#RXBUF, DATADR	; Start at the beginning of the RXBUF
.IF NE ECTMOP
	BIT	#ER.RER, R4
	BEQ	12$
	INC	MCRXPE		; Inc. packets received-with-errors counter
	BR	13$
12$:	INC	MCRXP		; Inc. packets-received counter
	ADD	R0, MCRXB	; Inc. bytes-received counter
	ADC	MCRXB+2
.ENDC
;-----------------------------------------------
; Calculate number of words for DMA transfer
13$:	TST	R0		; Check number of received bytes
	BNE	14$		; Not zero - continue
	BISB	#RX.ERR, ERRFLG	; Zero - set error flag, ...
	BIS	#ET.RDD,@#ECTST	; ... set "receive-done" bit and ...
	JMP	RXF$		; ... jump to finish
14$:	MOV	R0, DATBCN	; Data size in bytes (copy for futher use)
	BIT	#BT.00, R0	; Is it even?
	BEQ	15$		; Yes - continue
	INC	R0		; No - make it even
15$:	ASR	R0		; Convert to word number
	MOV	R0, DATWCN	; Data set size in words
;-----------------------------------------------
; Prepare status 1-st word template R0
	CLR	R5
	BIT	#<ER.CRR!ER.RDR>,R4 ; Did we get errors?
	BEQ	16$		; No - continue
	BIS	#RS.1GE, R5	; Yes - set error bit
	BIT	#ER.CRR, R4	; Did we get CRC error?
	BEQ	16$		; No - continue
	BIS	#RS.1CE, R5	; Yes - set error bit
16$:	BIT	#<ET.STP!ET.IEL!ET.INL>,R4 ; Loop-packet?
	BEQ	18$		; No - br to finish template preparation
	BIS	#RS.1ES, R5	; Yes - set loop-packet bit
	BIT	#ET.STP, R4	; Is it setup packet?
	BEQ	18$		; No - br to finish template preparation
	BIS	#3400, R5	; Yes - set bits 10:08 and, ...
	BIC	#ET.STP,@#ECTST	; ... clear S-bit in the emode register.
18$:	MOV	R5, STW1	; Store 1-st status word template
;===============================================
; Get first/next BDL block data
RXL$:	MOV	BDLL, 6(R2)	; Set to DMA address (low order bits)
	MOV	BDLH, 10(R2)	; Set DMA address (high order bits)
	CALL	GETBDL		; Get BDL data
	BCS	100$		; If error - br to error proc.
;-----------------------------------------------
; Process V-bit
	BIT	#AD.V, 2(R1)	; Check valid bit
	BNE	1$		; There is V-bit - continue
;	BIS	#<CS.RL!CS.RI>,@R3 ; There is no - set RL+RI bits ...
	BIS	#CS.RL, @R3	; There is no - set RL bits ...
	BR	RXF$		; ... in the CSR  and return
;-----------------------------------------------
; Calculate word count for the current transfer
1$:	MOV	DATWCN, R4	; Data size in words to R4
	BNE	2$		; If data size = 0 then ...
	BIS	#CS.RL,@R3	; ... set RL bit in the CSR ...
	BR	RXF$		; ... and return
2$:	ADD	WCOUNT, R4	; Compare size of received data and ...
				; ... DMA data buffer size
	BLE	4$
;
; Size of received data is greater then DMA data buffer size
	MOV	R4, DATWCN	; Store size of the reminder for the futher loop(s)
	MOV	WCOUNT, R5	; Use WCOUNT for DMA operation ...
	MOV	R5, 2(R2)	; ... and store int in the register
	ASL	R5		; Convert to byte count 2's compl.
	ADD	R5, DATBCN	; Correct remaining byte count
	NEG	R5		; 2's complement
	MOV	R5, BCOUNT	; Number of bytes in the DMA data block
	BR	7$
;
; Size of received data is less then (or equal to) DMA data buffer size
4$:	MOV	DATWCN, R5	; Word counter
	NEG	R5		; 2's compl.
	MOV	R5, 2(R2)	; Set DMA word counter register
	MOV	DATBCN, BCOUNT	;
	CLR	DATWCN		; No - just clear it
;-----------------------------------------------
; DMA transfer
7$:	MOV	DATADR, 4(R2)	; Initial local address to DMA reg
	BIS	#RX.BFS,@R2	; Select receive buffer
	CALL	DMASRD		; Start DMA operation
	BIC	#RX.BFS,@R2	; Deselect receive buffer
	BCS	100$		; Got error - br to finish
	MOV	4(R2), DATADR	; Store next buffer address for futher use
;-----------------------------------------------
; Status words processing
	MOV	STW1, R4	; Get 1-st status word template
	TST	DATWCN		; Is this the last data set?
	BNE	9$		; No  - br to set "used" and not "last"
	BIS	#ET.RDD,@#ECTST	; yes - set "receive-done" bit ...
	BR	10$		; Br to final step
9$:	BIS	#UNLST, R4	; No - set "used" and not "last"
;
; Calculate number of bytes, store and send status words
10$:	MOV	BCOUNT, R5	; Get byte count
	BIT	#RS.1ES, R4	; Loopback packet?
	BNE	12$		; Yes - br to continue
	SUB	#60., R5	; No - modify byte count
12$:	MOV	R5, R0		; Copy number of bytes to R0
	BIC	#^C<RS.1BL>, R0	; Clear all except high bits and ...
	BIS	R0, R4		; ... save it in the 1-st status word
14$:	MOVB	R5, STW2	; Save low bits of the byte count ...
	MOVB	R5, STW2+1	; ... value in the  2-ns status word
	MOV	R4, STW1	; Store 1-st status word
	CALL	STWPR		; Send status words to host
	BCS	100$		; Carry is set - NXM error
	TST	DATWCN		; Is this the last data set?
	BNE	20$
	BIS	#CS.RI, @R3	; Signal reception is completed
;-----------------------------------------------
; Calculate next BDL address
20$:	ADD	#12., BDLL	; 6 words offset, ...
	ADC	BDLH		; ... add carry bit ...
	BR	RXL$		; ... and loop
;-----------------------------------------------
; Carry is set NXM error
100$:	BISB	#<RX.ERR!NX.ERR>,ERRFLG	; Set error flags
	BIS	#<CS.NI!CS.XL!CS.RL!CS.XI>,@R3 ; Set NI-bit in the CSR
;
; Return
RXF$:	RETURN
;
	.SBTTL	- BD ROM operation
;===========================================================================
;
PBDROM:	BIS	#CS.RL, @R3	; Restore RL-bit in the CSR
;-----------------------------------------------
; Rewrite from ROM to RX buffer
	BIC	#EA.RXB,@#EGMOD	; RXBUF address to bus mode
	MOV	#BDROM, R4	; BD ROM address to R4
	MOV	#RXBUF, R5	; RX buffer address to R5
	MOV	#BDRSIZ, R0	; BD ROM size in words ...
	ASR	R0		; ... to R0
1$:	MOV	(R4)+, (R5)+	; Rewrite BD ROM data
	SOB	R0, 1$		; to RX buffer
	BIC	#CS.RL, @R3	; Inform RX buffer is ready
; Wait for the BD=0
2$:	BIT	#CS.BD, @R3
	BNE	2$
;-----------------------------------------------
; Start data transfer
	MOV	@#LQARLL, BDLL	; Get initial Rx BDL low order address bits
	MOV	@#LQARLH, BDLH	; Get initial Rx BDL high order address bits
	MOV	#RXBUF, DATADR	; Start at the beginning of the RXBUF
	MOV	#BDRSIZ, R5
	MOV	R5, DATBCN	; Data set size in words
	ASR	R5
	MOV	R5, DATWCN	; Data set size in bytes
;
; Get first/next BDL block data
PBDLC$:	MOV	BDLL, 6(R2)	; Set to DMA address (low order bits)
	MOV	BDLH, 10(R2)	; Set DMA address (high order bits)
	CALL	GETBDL		; Get BDL data
	BCS	100$		; If error - br to error proc.
;
; Process V-bit
	BIT	#AD.V, 2(R1)	; Check valid bit
	BNE	1$		; There is V-bit - continue
	BIS	#<CS.RL!CS.RI>,@R3 ; Set RL-bit in the CSR
	BR	PBDEX$		; There is no V-bit - return
;
; Calculate word count
1$:	MOV	DATWCN, R4	; Data size in words to R4
	BNE	3$		; If data size = 0 then ...
	BIS	#CS.RL, @R3	; ... set RL-bit in the CSR ...
	BR	PBDEX$		; ... and return
;
3$:	ADD	WCOUNT, R4	; Compare size of received data and ...
				; ... DMA data buffer size
	MOV	R4, DATWCN	; Store size of the reminder for the futher loop(s)
	BLT	7$		; Size of received data is smaller
;
; Size of received data is greater then (or equal to) DMA data buffer size
	MOV	WCOUNT, R5	; In this case we operate with ...
	MOV	R5, 2(R2)	; ... DMA data buffer size
; Calc. number of bytes
	TST	R4		; DATWCN = 0?
	BNE	5$		; No - calculate bytes number
	MOV	DATBCN, BCOUNT	; Yes - store for status word operation ...
	BR	9$		; ... and br to DMA operation
5$:	ASL	R5		; Convert to byte count 2's compl.
	ADD	R5, DATBCN	; Correct remaining byte count
	NEG	R5		; 2's complement
	MOV	R5, BCOUNT	; Number of bytes in the DMA data block
	BR	9$		; Br to DMA operation
;
; Size of received data is less then DMA data buffer size
7$:	MOV	R4, 2(R2)	; Set words number for DMA operation
	MOV	DATBCN, BCOUNT	; Set bytes number for status words operation
;
; DMA transfer
9$:	MOV	DATADR, 4(R2)	; Initial local address to DMA reg
	BIS	#RX.BFS,@R2	; Select receive buffer
	CALL	DMASRD		; Start DMA operation
	BIC	#RX.BFS,@R2	; Deselect receive buffer
	BCS	100$		; Got error - br to finish
	MOV	4(R2), DATADR	; Store next buffer address for futher use
;
; Prepare and send status words
	TST	DATWCN		; Is this the last data set?
	BLE	10$		; Yes - set normal status word bits
	MOV	#UNLST, R4	; No - set "used" and not "last" data set
	BR	12$		;
10$:	MOV	#BT.15, R4	; Init 1-st status word
12$:	CLR	R5		; Init 2-nd status word
; Calculate number of bytes, store status words
	MOV	BCOUNT, R5	; Get number of transfered bytes
	MOVB	R5, STW2	; Save byte count value ...
	MOVB	R5, STW2+1	; ... to the 2-nd status word
	BIC	#^C<RS.1BL>, R5	; Clear all except high bits
	BIS	R5, R4		; Set the bits to the 1-st word
	MOV	R4, STW1	; Store 1-st status word
	CALL	STWPR		; Send status words to host
	BCS	100$		; Carry is set - NXM error
;
; Calculate next BDL address
	ADD	#12., BDLL	; 6 words offset, ...
	ADC	BDLH		; ... add carry bit ...
	BR	PBDLC$		; ... and loop
;-----------------------------------------------
; Carry is set NXM error
100$:	BISB	#NX.ERR, ERRFLG	; Set error flags
	BIS	#<CS.NI!CS.XL!CS.RL!CS.XI>,@R3 ; Set NI-bit in the CSR
;
; Return
PBDEX$:	BIS	#EA.RXB,@#EGMOD	; RXBUF address to ethernet mode
	RETURN
;
.IF NE ECTMOP
	.SBTTL	- Send system message
;===========================================================================
; Send system message every 10 minutes.
;
TXSYSM:	MOV	@#ECTST, R0
	BIC	#^C<ET.STP!ET.EXL!ET.IEL!ET.INL>,R0 ; Loopback mode?
	BNE	1$				    ; Yes - br to return
	MOV	#SYSMES, R4	; System message address
	MOV	#SYSCNT, R0	; Size of the system message (bytes)
	CALL	SNDMB		; Copy and transmit operation
	BCS	1$
	CLRB	FSYSM		; Clear system message flag
	INC	SYSRCN		; Next receipt number
1$:	RETURN
.ENDC
;
	.SBTTL	 - Tests
;===========================================================================
; Run tests (if necessary)
;
TSTMOD:	BIC	#<VR.S3!VR.S2!VR.S1>,@#LQAVAR ; Clear test bits
	BIS	#1, @#LQABAS	; Block external bus access
;	BIS	#EA.LED,@#EGMOD	; Set indication
; 5 sec delay
	MOVB	TSEC, R0	; Calculate 2 seconds ...
	ADD	#2, R0		; ... time shift for the ...
	CMP	R0, #60.	; ... delay purpose ...
	BMI	1$		; ... and store the result ...
	SUB	#60., R0	; ... in a temporary ...
1$:	MOVB	R0, STW2	; ... variable
	CALL	MBFTST		; Test memory blocks
	BCS	8$		; If error - br to processing
	CALL	SACHK		; Test SA ROM checksum
	BCS	8$		; If error - br to processing
	CALL	BDCHK		; Test BD ROM checksum
	BCS	8$		; If error - br to processing
	CALL	MDCINI		; Ethernet transceiver initialization
	BCS	8$
;
2$:	CMPB	TSEC, STW2	; Just the delay
	BNE	2$
;
8$:	MOV	@#EGMOD, R0	; Get EGMOD value
	BIC	#EA.LED, R0	; Clear led bits
	MOV	@#LQAVAR, R4	; Get LQAVAR value
	BIC	#^C<VR.S3!VR.S2!VR.S1>,R4 ; Clear all except ...
					  ; ... test bits
	SWAB	R4		; Shift test result ...
	ASH	#-2, R4		; .. bits to the right (LSB)
	BIS	R4, R0		; Switch on leds in accordance ...
	MOV	R0, @#EGMOD	; ... with test result bits
	BIC	#<VR.RS>,@#LQAVAR ; Test result is ready
	BIC	#1, @#LQABAS	; Unblock external bus access
;	BIT	#<VR.S3!VR.S2!VR.S1>,@#LQAVAR
;	BEQ	10$
;	HALT
10$:	RETURN
;
	.SBTTL	Internal routines
	.SBTTL	- BDL processing
;===========================================================================
;
GETBDL:	MOV	R1, 4(R2)	; Initial local address to DMA reg
	CLRB	ERRFLG		; Clear error flags
	MOV	#-1, 2(R2)	; Process 1 word
	CALL	DMASRD		; Start DMA read operation
	BCS	4$		; Return if error
	MOV	#-3, 2(R2)	; Process 3 words
	CALL	DMASWR		; DMA write operation
	BCS	4$		; Return if error
;
; Get and store BDL data
	MOV	2(R1), 10(R2)	; Store high order address bits
	MOV	4(R1), 6(R2)	; Store low order address bits
;
; Process C-bit
	BIT	#AD.C, 2(R1)	; Check chain bit
	BEQ	2$		; No bit - continue
	MOV	2(R1), BDLH	; Save copy of the high order address bits
	MOV	4(R1), BDLL	; Save copy of the low order address bits
	BR	GETBDL		; Continue from the beginning
;
; Finalize operation
2$:	MOV	6(R1), R4	; Get buffer's word count
	MOV	R4, 2(R2)	; Store word count for futher DMA operations
	MOV	R4, WCOUNT	; Save copy
	CLC			; Normal return
4$:	RETURN
;
	.SBTTL	- DMA processing
;===========================================================================
;
DMASRD:
	BIS	#DM.RDO,@R2	; Set read operation
	BR	DMAC$		; BR to main loop
DMASWR:
	BIS	#DM.WRO,@R2	; Set write operation
;
; Waiting for the DMA operation will be completed
DMAC$:	CLC			; Clear carry
1$:	BIT	#DM.RDY,@R2	; Ready?
	BEQ	1$		; Not yet - loop
	BIT	#DM.NXM,@R2	; NXM error?
	BEQ	2$		; No - normal exit
	SEC			; Yes - set carry
2$:	BIC	#<DM.RDO!DM.WRO>,@R2 ; Clear operation bits
	RETURN
;
	.SBTTL	- Status words processing
;===========================================================================
;
STWPR:	MOV	STW1, 10(R1)	; First status word
	MOV	STW2, 12(R1)	; Second status word
	MOV	BDLL, R4	; Get low order address bits
	MOV	BDLH, R5	; Get high order address bits
	ADD	#8., R4		; Calculate memory address ...
	ADC	R5		; ... to store status words
	MOV	R4, 6(R2)	; Set low order address bits
	MOV	R5, 10(R2)	; Set high order address bits
	MOV	#BDLSTW, 4(R2)	;
	MOV	#-2, 2(R2)	; Process 2 words
	CALL	DMASRD		; Start DMA read operation
	RETURN
;
	.SBTTL	- Setup packet processing
;===========================================================================
;
SPACK:	MOV	R1, -(SP)
	MOV	R2, -(SP)
	MOV	R3, -(SP)
;-----------------------------------------------
; Process setup control byte
;
	MOVB	SETUPB, R5	; Get the initial value
	BIC	#177400, R5	; Clear high bits
	MOV	R5, R4		; Save copy
	MOV	@#EGMOD, R1	; Get ether general register value
	BIC	#^C<EA.RXB!EA.TXB!EA.LED>,R1 ; Clear all except ...
				; ... ethernet address mux ...
				; ... control bits and led bits
; Promisc. and mcast bits
	ASH	#5, R4
	BIC	#^C<ET.PRM!ET.MCT>,R4 ; Clear all except needed bits
	BIS	R4, R1		; Combine information in R1
; Turn off LED bits
2$:	MOV	R5, R4		; Get copy of the setup byte
	ASH	#-2, R4		; Shift to the right position
	BIC	#^C<3>, R4	; Clear all except needed bits
	BEQ	4$		; No effect if 0
	BICB	LEDS(R4), R1	; Turn off correct LED
; Set register
4$:	MOV	R1, @#EGMOD	; Set the result in the register
;
; Set initial sanity timer value
	MOV	R5, R4
	BIC	#177600, R4	; Clear all except 6-0 bits
	ASH	#-3, R4		; Remove unused bits
	MOV	SNTIV(R4),SNTVAL ; Store initial value
;
; Sanity timer enable register = CS.SE
	BIT	#CS.SE, @#LQACSR
	BNE	5$
	BIC	ST.ENA, @#EGMOD
	BR	6$
5$:	BIS	ST.ENA, @#EGMOD
;
6$:	BIC	#177, R5	; Clear control bits
	BEQ	20$		; No MAC info - return
;-----------------------------------------------
; Process MAC target addresses
;
	MOV	#MACTAB, MTADR
	MOV	#TXBUF, R1	; Address of the setup block
	MOV	#2, R5		; 2 groups
10$:	MOV	#6, R4		; 6 bytes for each address

12$:	MOV	MTADR, R2	; Address in the memory block
	MOV	#3, R3		; 3 words to read
	MOV	(R1)+, R0	; Get first word
	SWAB	R0		; Skip first byte
	MOVB	R0, (R2)	; Store address byte
14$:	MOV	(R1)+, R0	; Get next word
	ADD	#6, R2		; Shift memory address
	MOVB	R0, (R2)	; Store address byte
	ADD	#6, R2		; Shift memory address
	SWAB	R0		; Next byte
	MOVB	R0, (R2)	; Store address byte
	SOB	R3, 14$		; Loop
;
	INC	MTADR		; Shift memory address
	SOB	R4, 12$		; Loop over the number of bytes ...
				; ... in the addess
	INC	R2		; Next memory byte address
	MOV	R2, MTADR
	ADD	#20, R1		; Shift in the setup block
	SOB	R5, 10$		; Loop
20$:	MOV	(SP)+, R3
	MOV	(SP)+, R2
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	- Reset sanity timer
;===========================================================================
;
SNTRES:
	MOV	SNTVAL, SNTCV	; Set initial value
	CLRB	SNTCK
	RETURN
;
	.SBTTL	- Compare MAC addresses
;===========================================================================
;
CMPMAC:
	MOV	R1, -(SP)
	MOV	R2, -(SP)
	MOV	R3, -(SP)
	MOV	#14., R5
	MOV	#MACTAB, R2
1$:	MOV	#RXBUF, R4
	MOV	R2, R3
	CLR	R0		; Init success counter
	MOV	#3, R1
2$:	CMP	(R4)+, (R3)+
	BNE	3$
	INC	R0
	SOB	R1, 2$
	CMP	#3, R0
	BEQ	4$
3$:	ADD	#6, R2
	SOB	R5, 1$
	SEC
	TST	(PC)+
4$:	CLC
	MOV	(SP)+, R3
	MOV	(SP)+, R2
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	- Init ethernet transceiver
;===========================================================================
; Install one of the working mode.
; Return:
;    Carry is cleared	- no error>, working mode is set
;    Cary is set	- error, couuld not set working mode
;
MDCINI:	CALL	MDWAIT
	BCS	6$
; Software reset
	MOV	#MD.SRS,@#EMDVAL ; Software reset
	CLR	R0
	CALL	MDCWR		; Write data
	BCS	6$		; If carry - br to error processing
; Try to set working mode
	MOV	#MDINIV, R4	; Init values address
	MOV	#MDINIC, R5	; Init values counter
1$:	MOV	(R4), @#EMDVAL	; Set initial parameters
	CLR	R0		; Register number 0
	CALL	MDCWR		; Write data
	BCS	6$		; If carry - br to error processing
2$:	CLR	R0		; Register number 0
	CALL	MDCRD		; Read data
	BCS	6$		; If carry - br to error processing
3$:	MOV	@#EMDVAL, R0	; Get MDC value
	CMP	(R4)+, R0	; Compare actual and expected values
	BEQ	8$		; If equal - br to normal return
	SOB	R5, 1$		; If not - loop over all init values
6$:	BIC	#<EA.LD3!EA.LD2>,@#EGMOD ; Turn off/on ...
	BIS	#EA.LD1,@#EGMOD		 ; ... correct LEDs
	BIC	#<VR.S3!VR.S2>,@#LQAVAR ; Clear/set ...
	BIS	#VR.S1,@#LQAVAR	; ... correct bits
	SEC			; Set error flag
	TST	(PC)+
8$:	CLC			; Clear carry (normal return)
	RETURN
;---------------------------------------------------------------------------
; Read MDC value
; Parameter:
;    R0 - register number
;
MDCRD:	BICB	#^C<MD.REG>, R0	; Clear all except register bits
	BICB	#MD.WR, R0	; Clear write bit (read operation)
	BR	MDCOP		; Br to start
;---------------------------------------------------------------------------
; Write MDC value
; Parameter:
;    R0 - register number
;
MDCWR:	BICB	#^C<MD.REG>, R0	; Clear all except register bits
	BISB	#MD.WR, R0	; Set write bit (write operation)
;---------------------------------------------------------------------------
; MDC operation
; Parameter:
;    R0 - control byte
;
MDCOP:	BISB	#MD.OP, R0	; Set start bit ...
	MOVB	R0, @#EMDCTR	; ... and start operation
	CALL	MDWAIT		; Wait
	RETURN
;---------------------------------------------------------------------------
; Wait ready status. 55 ticks timeout
;
MDWAIT:	MOV	R1, -(SP)
	MOVB	TTICK, R0	; Store current tick value
	ADD	#55, R0		; Add delay
	CMP	#60., R0	; More than 60?
	BPL	1$		; No - continue
	SUB	#60., R0	; Yes - subtract 60
1$:	MOV	@#EMDCTR, R1	; Get MDC status
	TST	R1		; Operation complete when ...
	BPL	2$		; ... ready bit is set ...
	BIT	#40, R1		; ... and start bit is cleared
	BEQ	3$		; Condition met, br to normal return
2$:	CMPB	R0, TTICK	; Timeout?
	BNE	1$		; No - loop
	BISB	#PH.ERR, ERRFLG	; Yes - set error flag ...
	SEC			; ... and carry
	TST	(PC)+
3$:	CLC			; Clear carry
	MOV	(SP)+, R1
	RETURN
;
.IF NE ECTMOP
	.SBTTL	- Populate TX-buffer and send the message
;===========================================================================
; Copy data from a memory block to the TX-buffer and send the message.
; Used for the loopbak and MOP frames.
; Inputs:
;    R4 - source data address;
;    R0 - size of the source data (bytes).
;
SNDMB:	MOV	R1, -(SP)
	MOV	R2, -(SP)
	MOV	#ECTST, R2
	MOV	#TXBUF, R5	; Tx bufffer address
	MOV	R0, R1		; Copy to R1
	NEG	R1		; Negate bytes number
	BIT	#BT.00, R0	; Is it even?
	BEQ	1$		; Yes - continue
	INC	R0		; No - make it even
1$:	ASR	R0		; Convert data size to words
	BIC	#EA.TXB, 10(R2)	; Set bus mode for TXBUF
2$:	MOV	(R4)+, (R5)+	; Copy source data to the ...
	SOB	R0, 2$		; ... transmitter buffer
	BIS	#EA.TXB, 10(R2)	; Restore ethernet mode for TXBUF
	MOV	R1, 2(R2)	; Set byte count to transmit.
;
	CALL	SNTRES		; Reset sanity timer
	BIS	#ET.TRD, @R2	; Set "ready-to-transmit" bit
3$:	BIT	#<ET.TXD!ER.TXR>,@R2 ; Transmitted or error?
	BEQ	3$		; Not yet, loop
	BIC	#ET.TRD, @R2	; Clear "ready-to-transmit" bit
;
; Error checking
	CLC
	BIT	#ER.TXR, @R2	; Got an error?
	BEQ	4$
	BISB	#TX.ERR, ERRFLG	; Set error flag
	SEC
4$:	MOV	(SP)+, R2
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	- Send ECTP reply frame
;===========================================================================
; Send Ethernet-Configuration-Testing-Protocol reply frame.
;
ECTPR:	MOV	RXBUF+16, R0	; Get skipCount
	CMP	RXBUF+20(R0),#2	; Function=2?
	BNE	4$		; No - return
	MOV	#RXBUF, R4	; Initial address to R4
	MOV	R4, R5		; Copy to R5
	BIT	#BT.00, (R4)	; Multicast or broadcast frame?
	BNE	1$		; Yes - br to reply
	CALL	CMPMAC		; No  - check SA
	BCS	4$		; Not matched - return
;
1$:	MOV	R5, R4
	ADD	#22, R5		; Shift to the destination MAC address
	MOV	#3, R0		; Words counter
2$:	MOV	(R5)+, (R4)+	; Write data to the frame
	SOB	R0, 2$
	MOV	#SYSSRC, R5	; Board MAC address
	MOV	#3, R0		; Words counter
3$:	MOV	(R5)+, (R4)+	; Write data to the frame
	SOB	R0, 3$
	TST	(R4)+		; Skip protocol word
	MOV	#10, (R4)	; Set skipCount=0x0008
	MOV	#RXBUF, R4	; Initial address to R4
	MOV	@#ECNTB, R0	; Set frame size (bytes)
	CALL	SNDMB		; Transmit ECTP
4$:	RETURN
;
	.SBTTL	- Process Remote MOP frame (not tested)
;===========================================================================
; Process "Request ID" and "Boot ID" messages
MOPR:	MOV	RXBUF+20, R0	; Get code
;
; Check for the Request ID message code
	CMPB	#MOPRSM, R0	; Request ID?
	BNE	4$		; No - br to next check
;
; Process Request ID message
	MOV	#RXBUF+6, R4
	MOV	#SYSMES, R5
	MOV	#3, R0
1$:	MOV	(R5)+, (R5)+	; Rewrite dest address from the ...
	SOB	R0, 1$		; ... request message
	MOV	SYSRCN, STW1	; Copy original receipt number
	MOV	RXBUF+22,SYSRCN	; Rewrite receipt number from the ...
				; ... request message
	MOV	#SYSMES, R4	; System message address
	MOV	#SYSCNT, R0	; System message byte count
	CALL	SNDMB		; Send the message
	MOV	#SYSMCA, R4
	MOV	#SYSMES, R5
	MOV	#3, R0
2$:	MOV	(R4)+, (R5)+	; Restore oroginal multicast ...
	SOB	R0, 2$		; ... source address
	MOV	STW1, SYSRCN	; Restore receipt number
	BR	9$
;
; Check for the Boot ID message code
4$:	CMPB	#MOPRBM, R0	; Request boot?
	BNE	10$
;
; Process Boot ID message
	BIT	#RB.ENA,@#EGMOD	; Is remote boot enabled?
	BEQ	10$		; No - send to the host
	CALL	CHKVRC		; Check verification code
	BCS	10$		; Not macthed - send to the host
8$:	BIS	#ST.RST,@#EGMOD ; Generate BDCOK (reboot host)
9$:	CLC
	TST	(PC)+
10$:	SEC
	RETURN
;
	.SBTTL	- Check verification code (not tested)
;===========================================================================
; Input:
;   R0 - 1-st code value in the high byte
;
; Return:
;   Carry is cleared	- matched o zero code (success).
;   Carry is set	- not matched
;
CHKVRC:	MOV	#4, R5		; Word count of the verification code
	MOV	#LVCODE, R4	; Is verification code = 0?
1$:	TST	(R4)+		; If yes - normal return,
	BNE	2$		; otherwise retun with error
	SOB	R5, 1$
	BR	9$
; Compare codes
2$:	SWAB	R0
	MOV	#LVCODE+1, R4	; Local verification code address
	CLR	R5		; Address index
	CMPB	R0, LVCODE	; Compare first byte
	BNE	10$		; Not matched - return with error
3$:	MOV	RXBUF+22(R5),R0	; Get next word from the frame
	CMPB	(R4)+, R0	; Compare codes
	BNE	10$		; Not matched - return with error
	INC	R5		; Matched - inc. address index
	SWAB	R0		; Next byte
	CMPB	(R4)+, R0	; Compare codes
	BNE	10$		; Not matched - return with error
	INC	R5		; Matched - inc. address index
	CMP	#6, R5		; Penultimate byte?
	BNE	3$		; No - loop
	MOV	RXBUF+22(R5),R0	; Get next word and ...
	SWAB	R0		; ... last code
	CMPB	(R4), R0	; Compare codes
	BNE	10$		; Not matched - return with error
9$:	CLC			; Matched - normal return
	TST	(PC)+
10$:	SEC
	RETURN
.ENDC
;
	.SBTTL	- RX/TX memory test
;===========================================================================
; RX/TX memory test
;
MBFTST:	MOV	R2, -(SP)
	MOV	#EGMOD, R2
	BIC	#EA.RXB, @R2	; Set bus mode for RXBUF
	BIC	#EA.TXB, @R2	; Set bus mode for TXBUF
; RXBUF test
	MOV	#RXBUF, R4	; Initial memory address
	MOV	#RXBSIZ, R5	; Size of memory (words)
	CALL	BFTST		; Call test
	BCS	1$		; If error - break
; TXBUF test
	MOV	#TXBUF, R4	; Initial memory address
	MOV	#TXBSIZ, R5	; Size of memory (words)
	CALL	BFTST		; Call test
	BCC	2$		; No error - continue
; Error processing
1$:	BIS	#<VR.S3!VR.S2>,@#LQAVAR ; Set error bits
; Return
2$:	BIS	#EA.RXB, @R2	; Restore ethernet mode for RXBUF
	BIS	#EA.TXB, @R2	; Restore ethernet mode for TXBUF
	MOV	(SP)+, R2
	RETURN
;---------------------------------------------------------------------------
; Very simple memory test
;
BFTST:	MOV	R1, -(SP)
	MOV	R2, -(SP)
	MOV	R3, -(SP)
	MOV	R4, R2		; Memory address
	MOV	R5, R0		; Word counter
	CLR	R1		; Initial test value
	CLR	R3		; Init error counter
1$:	MOV	R1, (R2)	; Write test value
	CMP	R1, (R2)+	; Read and compare
	BEQ	2$		; If equal - continue
	INC	R3		; If not - inc. error number
2$:	INC	R1		; Inc. test value
	SOB	R0, 1$		; Loop
	MOV	R4, R2		; Memory address
	MOV	R5, R0		; Word counter
	MOV	#177777, R1	; Initial test value
3$:	MOV	R1, (R2)	; Write test value
	CMP	R1, (R2)+	; Read and compare
	BEQ	4$		; If equal - continue
	INC	R3		; If not - inc. error number
4$:	DEC	R1		; Dec. test value
	SOB	R0, 3$		; Loop
	TST	R3		; Check error
	BEQ	8$		; No error - br to return
	SEC			; Set carry
	TST	(PC)+		; Br to return
8$:	CLC			; Clear carry (no errors)
	MOV	(SP)+, R3
	MOV	(SP)+, R2
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	- SA ROM check
;===========================================================================
; Subroutine to calculate station address ROM checksum
; Minor modification of the original source.
; Original source added by Dave Scoda to
; the CZQNAEO DEQNA FUNCTIONAL TEST Mar-1986
;
SACHK:	MOV	R1, -(SP)
	CLR	R5		; Checksum
	MOV	#ESADR, R4
	MOV	#3, R1
2$:	MOV	R5, R0
	ASL	R0
	BIT	#100000, R5
	BEQ	3$
	MOV	R0, R5
	INC	R5
	BR	4$
3$:	MOV	R0, R5
4$:	CLC
	ADD	(R4)+, R5
	ADC	R5
	SOB	R1, 2$
; Compare calculated and stored
	MOV	(R4), R1
	CMP	R1, R5
	BEQ	10$
	BIS	#VR.S2,@#LQAVAR ; Set error bits
	SEC
	TST	(PC)+
10$:	CLC
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	- BD ROM check
;===========================================================================
; Subroutine to calculate BD ROM checksum
;
BDCHK:	MOV	R1, -(SP)
	MOV	#BDROM, R5	; ROM address to R5
	MOV	#BDRSIZ, R4	; Number of bytes to R3
	TST	-(R4)		; -2 bytes
	CLR	R0		; Calculated CRC is in R0
1$:	MOVB	(R5)+, R1	; Get data byte
	BIC	#177400, R1	; Clear high byte
	ADD	R1, R0		; Sum
	SOB	R4, 1$		; Loop
; Compare calculated and stored
	MOV	(R5), R4	; Get stored CRC
	CMP	R0, R4		; Is equal?
	BEQ	10$		; Yes - br to normal return
	BIS	#<VR.S3!VR.S2!VR.S1>, @#LQAVAR ; No - set error bits ...
	SEC			; ... set carry ...
	TST	(PC)+		; ... and return
10$:	CLC
	MOV	(SP)+, R1
	RETURN
;
	.SBTTL	Timer interrupt handler
;===========================================================================
;
TMRIRQ:
;-----------------------------------------------
; Ticks
	INCB	TTICK		; Tics counter
	INCB	SNTCK
	CMPB	TTICK, #50.	; Got 50 tics?
	BNE	100$		; No - br to finish
	CLRB	TTICK		; Clear tics counter
;-----------------------------------------------
;  Seconds
	INCB	TSEC		; Increment seconds counter
	CMPB	TSEC, #60.	; Got 60 seconds?
	BNE	100$		; No - br to finish
	CLRB	TSEC		; Clear seconds counter
;-----------------------------------------------
; Minutes
	INCB	TMIN		; Increment minutes counter
	INCB	TSYSM		; Increment system message counter
	CMPB	TMIN,#60.	; Got 60 minutes?
	BNE	100$		; Not yet - br to RTI
	CLRB	TMIN		; Yes - clear minutes counter and ...
;-----------------------------------------------
; Process system message counter
100$:	CMPB	TSYSM, #8.
	BNE	102$
	CLRB	TSYSM
	INCB	FSYSM
;-----------------------------------------------
; Process 5-ticks counter
102$:	BIT	#ST.ENA, @#EGMOD
	BEQ	110$
	CMPB	SNTCK, #5
	BNE	110$
	CLRB	SNTCK
	INC	SNTCV
	BNE	110$
;-----------------------------------------------
; Sanity counter is equal to zero
	BIS	#ST.RST,@#EGMOD ; Yes - generate BDCOK
;
110$:	RTI
;
	.SBTTL	Data section
;===========================================================================
;
MTADR:	.BLKW	1	; Address of the MACTAB entry
MACTAB:	.BLKB	84.	; Mac address table
DATADR:	.BLKW	1	; Data address offset
DATWCN:	.BLKW	1	; Current data size in words
DATBCN:	.BLKW	1	; Current data size in bytes
BCOUNT:	.BLKW	1	; Total data size in bytes
WCOUNT:	.BLKW	1	; DMA ops. data size (2's compl.)
RBCNT:	.BLKW	1	; Byte count copy
RECTST:	.BLKW	1	; Ether status copy
BDLH:	.BLKW	1	; BDL high address bits
BDLL:	.BLKW	1	; BDL low address bits
STW1:	.BLKW	1	; 1-st status word
STW2:	.BLKB	1	; 2-nd status word
	.BLKB	1
MDINIV:	.WORD	20400	; Ethernet init: 100 Mb, full duplex, no autoneg.
	.WORD	00400	; Ethernet init: 10 Mb, full duplex, no autoneg.
	.WORD	20000	; Ethernet init: 100 Mb, half duplex, no autoneg.
	.WORD	00000	; Ethernet init: 10 Mb, half duplex, no autoneg.
MDINIC	= <.-MDINIV>/2
;-----------------------------------------------
; Sanity timer
SNTIV:	.WORD	-3	; -0.3 sec (instead of 0.25)
	.WORD	-10.	; -1 sec
	.WORD	-40.	; -4 sec
	.WORD	-160.	; -16 sec
	.WORD	-600.	; -1 min
	.WORD	-2400.	; -4 min
	.WORD	-9600.	; -16 min
	.WORD	-38400.	; -64 min
SNTVAL:	.WORD	-2400.	; Initial value (-4 min.)
SNTCV:	.BLKW	1	; Current counter
SETUPB:	.BLKB	1	; Setup control byte copy
SNTCK:	.BYTE	0	; 5-ticks counter
;-----------------------------------------------
; LEDS converter
LEDS:	.BYTE	0	; Leds - 000
	.BYTE	1	; Leds - 001
	.BYTE	2	; Leds - 010
	.BYTE	4	; Leds - 100
;-----------------------------------------------
; Flags
ERRFLG:	.BYTE	0	; Error flags
FSYSM:	.BYTE	0	; System message flag
;
.IF NE ECTMOP
;-----------------------------------------------
; System message
SYSMES:	.BLKB	6	; Destination MAC address
SYSSRC:	.BLKB	6	; Source MAC address
	.WORD	1140	; The remote console type 0x0260
	.WORD	28.	; The character count
	.BYTE	7	; Function code for system ID
	.BYTE	0	; Pad of zero
SYSRCN:	.WORD	0	; Receipt number
; MOP version
	.WORD	1	; Type
	.BYTE	3	; Length
	.BYTE	3	; Version
	.BYTE	1	; Eco
	.BYTE	0	; User Eco
; Function
	.WORD	2	; Type
	.BYTE	2	; Length
	.BYTE	0	; Value 1
	.BYTE	0	; Value 2
; HW address
	.BYTE	7	; Type ...
	.BYTE	0	; ... (0x7)
	.BYTE	6	; Length
SYSDA:	.BLKB	6	; Default address from SA ROM
; Device
	.WORD	37.	; Type
	.BYTE	1	; Length
	.BYTE	21	; The DELQA device code (0x11)
SYSPAD:	.BLKB	146.	; Pad/Parameters
SYSCNT	= .-SYSMES
SYSPDC	= .-SYSPAD
SYSMCA:	.BYTE	253	; AB  Destination
	.BYTE	000	; 00  MAC address
	.BYTE	000	; 00
	.BYTE	002	; 02
	.BYTE	000	; 00
	.BYTE	000	; 00
;
; Boot verification code
LVCODE:	.BYTE	0,0,0,0,0,0,0,0
;
;-----------------------------------------------
; MOP counters
MCLZ:	.BLKW	1	; Seconds Since Last Zeroed
MCRXB:	.BLKW	2	; Bytes Received
MCTXB:	.BLKW	2	; Bytes Transmitted
MCRXP:	.BLKW	2	; Packets (Frames) Received
MCTXP:	.BLKW	2	; Packets (Frames) Transmitted
MCMRXB:	.BLKW	2	; Multicast Bytes Received
MCMRXP:	.BLKW	2	; Multicast Packets (Frames) Received
MCTXPD:	.BLKW	2	; Packets Transmitted: (Initially) Deferred
MCTXPS:	.BLKW	2	; Packets Transmitted (single collision)
MCTXPM:	.BLKW	2	; Packets Transmitted (multiple collision)
MCTXPA:	.BLKW	1	; Transmit Packets Aborted (Send failure)
MCTPAM:	.BLKW	1	; Transmit Packets Aborted Bitmap
MCRXPE:	.BLKW	1	; Packets Received with Error
MCRPEM:	.BLKW	1	; Packets Received with Error Bitmap
MCHCR1:	.BLKW	1	; Reserved for Host Counter Word
MCRPL:	.BLKW	1	; Receive Packet Lost
MCHCR2:	.BLKW	1	; Reserved for Host Counter Word
MCMTXB:	.BLKW	2	; Multicast Bytes Transmitted
MCRES:	.BLKW	2	; Reserved
MCBABC:	.BLKW	1	; Babble Counter
MOPCNT	= <.-MCLZ>/2
.ENDC
;-----------------------------------------------
; Timer counters
TTICK:	.BYTE	0	; Ticks
TSEC:	.BYTE	0	; Seconds
TMIN:	.BYTE	0	; Minutes
TSYSM:	.BYTE	0	; System message timeout
;TCNT	= .-TTICK
	.EVEN
;-----------------------------------------------
	.END  0
